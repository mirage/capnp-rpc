<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Capability (capnp-rpc-lwt.Capnp_rpc_lwt.Capability)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">capnp-rpc-lwt</a> &#x00BB; <a href="../index.html">Capnp_rpc_lwt</a> &#x00BB; Capability</nav><h1>Module <code>Capnp_rpc_lwt.Capability</code></h1></header><aside><p>A capability is a reference to an object, or to a promise for an object. You can invoke methods on a capability even while it is still only a promise.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>+'a t</span></code></dt><dd><p>An <code>'a t</code> is a capability reference to a service of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-broken"><a href="#val-broken" class="anchor"></a><code><span class="keyword">val</span> broken : <a href="../../../capnp-rpc/Capnp_rpc/Exception/index.html#type-t">Capnp_rpc.Exception.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>broken ex</code> is a broken capability, with problem <code>ex</code>. Any attempt to call methods on it will fail with <code>ex</code>.</p></dd></dl><dl><dt class="spec value" id="val-when_broken"><a href="#val-when_broken" class="anchor"></a><code><span class="keyword">val</span> when_broken : <span>(<a href="../../../capnp-rpc/Capnp_rpc/Exception/index.html#type-t">Capnp_rpc.Exception.t</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>when_broken fn x</code> calls <code>fn problem</code> when <code>x</code> becomes broken. If <code>x</code> is already broken, <code>fn</code> is called immediately. If <code>x</code> can never become broken (e.g. it is a near ref), this does nothing. If <code>x</code>'s ref-count reaches zero without <code>fn</code> being called, it will never be called.</p></dd></dl><dl><dt class="spec value" id="val-when_released"><a href="#val-when_released" class="anchor"></a><code><span class="keyword">val</span> when_released : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>when_released t fn</code> will call <code>fn ()</code> when <code>t</code>'s ref-count drops to zero. This is used for caches, to remove entries when they become invalid. For promises, <code>fn</code> will be transferred to the resolution if resolved. For broken caps, this method does nothing (exceptions are never released).</p></dd></dl><dl><dt class="spec value" id="val-problem"><a href="#val-problem" class="anchor"></a><code><span class="keyword">val</span> problem : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../../../capnp-rpc/Capnp_rpc/Exception/index.html#type-t">Capnp_rpc.Exception.t</a> option</span></code></dt><dd><p><code>problem t</code> is <code>Some ex</code> if <code>t</code> is broken, or <code>None</code> if it is still believed to be healthy. Once a capability is broken, it will never work again and any calls made on it will fail with exception <code>ex</code>.</p></dd></dl><dl><dt class="spec value" id="val-wait_until_settled"><a href="#val-wait_until_settled" class="anchor"></a><code><span class="keyword">val</span> wait_until_settled : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>wait_until_settled x</code> resolves once <code>x</code> is a &quot;settled&quot; (non-promise) reference. If <code>x</code> is a near, far or broken reference, this returns immediately. If it is currently a local or remote promise, it waits until it isn't. <code>wait_until_settled</code> takes ownership of <code>x</code> until it returns (you must not <code>dec_ref</code> it before then).</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(bool, <span>[ `Unsettled ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>equal a b</code> indicates whether <code>a</code> and <code>b</code> designate the same settled service. Returns <code>Error `Unsettled</code> if <code>a</code> or <code>b</code> is still a promise (and they therefore may yet turn out to be equal when the promise resolves).</p></dd></dl><div class="spec module" id="module-Request"><a href="#module-Request" class="anchor"></a><code><span class="keyword">module</span> <a href="Request/index.html">Request</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-call"><a href="#val-call" class="anchor"></a><code><span class="keyword">val</span> call : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../StructRef/index.html#type-t">StructRef.t</a></span></code></dt><dd><p><code>call target m req</code> invokes <code>target#m req</code> and returns a promise for the result. Messages may be sent to the capabilities that will be in the result before the result arrives - they will be pipelined to the service responsible for resolving the promise. The caller must call <code>StructRef.dec_ref</code> when finished with the result (consider using one of the <code>call_*</code> functions below instead for a simpler interface).</p></dd></dl><dl><dt class="spec value" id="val-call_and_wait"><a href="#val-call_and_wait" class="anchor"></a><code><span class="keyword">val</span> call_and_wait : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span> * <span>(unit <span>&#45;&gt;</span> unit)</span>, <span>[&gt; <span>`Capnp of <a href="../../../capnp-rpc/Capnp_rpc/Error/index.html#type-t">Capnp_rpc.Error.t</a></span> ]</span>)</span> Lwt_result.t</span></code></dt><dd><p><code>call_and_wait t m req</code> does <code>call t m req</code> and waits for the response. This is simpler than using <code>call</code>, but doesn't support pipelining (you can't use any capabilities in the response in another message until the response arrives). On success, it returns <code>Ok (response, release_response_caps)</code>. Call <code>release_response_caps</code> when done with the results, to release any capabilities it might contain that you didn't use (remembering that future versions of the protocol might add new optional capabilities you don't know about yet). If you don't need any capabilities from the result, consider using <code>call_for_value</code> instead. Doing <code>Lwt.cancel</code> on the result will send a cancel message to the target for remote calls.</p></dd></dl><dl><dt class="spec value" id="val-call_for_value"><a href="#val-call_for_value" class="anchor"></a><code><span class="keyword">val</span> call_for_value : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>, <span>[&gt; <span>`Capnp of <a href="../../../capnp-rpc/Capnp_rpc/Error/index.html#type-t">Capnp_rpc.Error.t</a></span> ]</span>)</span> Lwt_result.t</span></code></dt><dd><p><code>call_for_value t m req</code> is similar to <code>call_and_wait</code>, but automatically releases any capabilities in the response before returning. Use this if you aren't expecting any capabilities in the response.</p></dd></dl><dl><dt class="spec value" id="val-call_for_value_exn"><a href="#val-call_for_value_exn" class="anchor"></a><code><span class="keyword">val</span> call_for_value_exn : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span> Lwt.t</span></code></dt><dd><p>Wrapper for <code>call_for_value</code> that turns errors into Lwt failures.</p></dd></dl><dl><dt class="spec value" id="val-call_for_unit"><a href="#val-call_for_unit" class="anchor"></a><code><span class="keyword">val</span> call_for_unit : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span><span>(unit, <span>[&gt; <span>`Capnp of <a href="../../../capnp-rpc/Capnp_rpc/Error/index.html#type-t">Capnp_rpc.Error.t</a></span> ]</span>)</span> Lwt_result.t</span></code></dt><dd><p>Wrapper for <code>call_for_value</code> that ignores the result.</p></dd></dl><dl><dt class="spec value" id="val-call_for_unit_exn"><a href="#val-call_for_unit_exn" class="anchor"></a><code><span class="keyword">val</span> call_for_unit_exn : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p>Wrapper for <code>call_for_unit</code> that turns errors into Lwt failures.</p></dd></dl><dl><dt class="spec value" id="val-call_for_caps"><a href="#val-call_for_caps" class="anchor"></a><code><span class="keyword">val</span> call_for_caps : <span><span class="type-var">'t</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="../index.html#module-StructStorage">StructStorage</a>.reader_t</span>)</span> Capnp.RPC.MethodID.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Request/index.html#type-t">Request.t</a></span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'b</span> <a href="../StructRef/index.html#type-t">StructRef.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>call_for_caps target m req extract</code> is a wrapper for <code>call</code> that passes the results promise to <code>extract</code>, which should extract any required capability promises from it. In the common case where you want a single cap &quot;foo&quot; from the result, use <code>call_for_caps target m req Results.foo_get_pipelined</code>. When the remote call finally returns, the result will be released automatically.</p></dd></dl><dl><dt class="spec type" id="type-resolver"><a href="#type-resolver" class="anchor"></a><code><span class="keyword">type</span> <span>'a resolver</span></code></dt><dd><p>An <code>'a resolver</code> can be used to resolve a promise for an <code>'a</code>. It can only be used once.</p></dd></dl><dl><dt class="spec value" id="val-promise"><a href="#val-promise" class="anchor"></a><code><span class="keyword">val</span> promise : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-resolver">resolver</a></span></code></dt><dd><p><code>promise ()</code> returns a fresh local promise and a resolver for it. Any calls made on the promise will be queued until it is resolved.</p></dd></dl><dl><dt class="spec value" id="val-resolve_ok"><a href="#val-resolve_ok" class="anchor"></a><code><span class="keyword">val</span> resolve_ok : <span><span class="type-var">'a</span> <a href="index.html#type-resolver">resolver</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>resolve_ok r x</code> resolves <code>r</code>'s promise to <code>x</code>. <code>r</code> takes ownership of <code>x</code> (the caller must use <code>inc_ref</code> first if they want to continue using it).</p></dd></dl><dl><dt class="spec value" id="val-resolve_exn"><a href="#val-resolve_exn" class="anchor"></a><code><span class="keyword">val</span> resolve_exn : <span><span class="type-var">'a</span> <a href="index.html#type-resolver">resolver</a></span> <span>&#45;&gt;</span> <a href="../../../capnp-rpc/Capnp_rpc/Exception/index.html#type-t">Capnp_rpc.Exception.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>resolve_exn r x</code> breaks <code>r</code>'s promise with exception <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-inc_ref"><a href="#val-inc_ref" class="anchor"></a><code><span class="keyword">val</span> inc_ref : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>inc_ref t</code> increases the ref-count on <code>t</code> by one.</p></dd></dl><dl><dt class="spec value" id="val-dec_ref"><a href="#val-dec_ref" class="anchor"></a><code><span class="keyword">val</span> dec_ref : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>dec_ref t</code> decreases the ref-count on <code>t</code> by one. When the count reaches zero, the capability is released. This may involve sending a notification to a remote peer. Any time you extract a capability from a struct or struct promise, it must eventually be freed by calling <code>dec_ref</code> on it.</p></dd></dl><dl><dt class="spec value" id="val-with_ref"><a href="#val-with_ref" class="anchor"></a><code><span class="keyword">val</span> with_ref : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> Lwt.t</span></code></dt><dd><p><code>with_ref t fn</code> runs <code>fn t</code> and then calls <code>dec_ref t</code> (whether <code>fn</code> succeeds or not).</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> Fmt.t</span></code></dt></dl></div></body></html>